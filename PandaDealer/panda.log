Random seed: 42
Time limit: 1800 seconds
Reading input from domain-p02.psas.
- State has 24 bits divided into 24 mutex groups.
- Domain contains 47 actions.
- Domain contains 76 tasks.
- Domain contains 80 methods.
- The initial state contains 8 set bits.
- The initial task is "__top[]".
- State-based goal contains 3 bits.
- Instance is totally-ordered: yes
- Instance has unique paths: yes
- Instance is parallel sequences: yes
Calculating preconditions and effects of compound tasks... 
- Inference time 0.001 seconds 
Calculate SCCs...
- Number of SCCs: 74
- The problem is cyclic
- Number of cyclic SCCs: 2
- Number of cyclic SCCs of size 1: 0
Selected Planning Algorithm: progression searchParsing heuristics ...
Number of specified heuristics: 1
Generate 1

RC Factory: CMA 0
- a combination of cost estimate and admissible heuristic is used -> using admissible correction of heuristic value (this is bad when you do not want to find optimal plans).
Heuristic #0 = hhRC2(lmc;cost;correct count)
Search config:
 - type: cost optimal
 - weight: 1
 - suboptimal: false
Visited List configured
- mode: total order
- hashs to use: state task task-sequence
- memory information: topological ordering
- Visited list allows deletion of search nodes: true
Search Configuration
- Using JAIR 2020 progression algorithm
- Search is stopped after first solution is found.
- A* Search
- Distance G is "action costs"
- Status: Solved
Search Results
- Search time 0.002 seconds
- Dead-ends detected 1 nodes 
- Visited list time 0.00022 seconds
- Visited list inserts 40
- Visited list pruned 6
- Visited list contains 34
- Visited list hash collisions 6
- Visited list used hash buckets 34
- Generated 329 search nodes
  Calculated heuristic for 147 nodes
  One modifications 123
  Effectless actions 59
- including 123 one modification actions
- including 0 one modification methods
- and       59 progressions of effectless actions
- Generated 73500 nodes per second
- Final fringe contains 21 nodes
- Status: Solved
- Found solution of length 53
- Total costs of actions: 24
==>
6 __method_precondition_m1_do_navigate1[rover0,waypoint3]
7 visit[waypoint3]
16 __method_precondition_m4_do_navigate2[rover0,waypoint2,waypoint2,waypoint1]
17 navigate[rover0,waypoint3,waypoint1]
18 visit[waypoint1]
20 navigate[rover0,waypoint1,waypoint2]
21 unvisit[waypoint1]
22 unvisit[waypoint3]
23 __method_precondition_m5_empty_store[rover0store]
24 nop[]
25 sample_soil[rover0,rover0store,waypoint2]
56 __method_precondition_m0_do_navigate1[rover0,waypoint2]
57 visit[waypoint2]
60 navigate[rover0,waypoint2,waypoint1]
61 unvisit[waypoint2]
62 communicate_soil_data1[rover0,general,waypoint2,waypoint1,waypoint0]
63 __method_precondition_m1_do_navigate1[rover0,waypoint1]
64 visit[waypoint1]
103 navigate[rover0,waypoint1,waypoint3]
104 unvisit[waypoint1]
105 __method_precondition_m6_empty_store[rover0store]
106 drop[rover0,rover0store]
107 sample_rock[rover0,rover0store,waypoint3]
115 __method_precondition_m1_do_navigate1[rover0,waypoint3]
116 communicate_rock_data2[rover0,general,waypoint3,waypoint0]
138 __method_precondition_m1_do_navigate1[rover0,waypoint3]
139 nop[]
140 calibrate[rover0,camera0,objective1,waypoint3]
184 __method_precondition_m1_do_navigate1[rover0,waypoint3]
185 nop[]
186 take_image[rover0,waypoint3,objective1,camera0,high_res]
289 __method_precondition_m1_do_navigate1[rover0,waypoint3]
290 nop[]
291 communicate_image_data[rover0,general,objective1,high_res,waypoint3,waypoint0]
root 0
288 do_navigate1[rover0,waypoint3] -> m0_do_navigate1 289 290
287 m14_send_image_data_splitted_7[rover0,general,objective1,high_res] -> <_splitting_method_m14_send_image_data_splitted_7;m14_send_image_data_splitted_3[rover0,general,objective1,high_res,waypoint3];_splitting_method_m14_send_image_data_splitted_3;1;0,-1> 288 291
183 do_navigate1[rover0,waypoint3] -> m0_do_navigate1 184 185
181 m13_get_image_data_splitted_2[rover0,objective1,camera0,high_res] -> _splitting_method_m13_get_image_data_splitted_2 183 186
137 do_navigate1[rover0,waypoint3] -> m0_do_navigate1 138 139
134 m15_do_calibrate_splitted_6[rover0,camera0] -> <_splitting_method_m15_do_calibrate_splitted_6;m15_do_calibrate_splitted_1[rover0,camera0,waypoint3];_splitting_method_m15_do_calibrate_splitted_1;1;0,-1> 137 140
114 send_rock_data[rover0,waypoint3] -> m12_send_rock_data 115 116
102 do_navigate2[rover0,waypoint1,waypoint3] -> m3_do_navigate2 103
59 do_navigate2[rover0,waypoint2,waypoint1] -> m3_do_navigate2 60
58 do_navigate1[rover0,waypoint3] -> m1_do_navigate1 63 64 102 104
55 do_navigate1[rover0,waypoint1] -> m1_do_navigate1 56 57 59 61
31 m8_send_soil_data_splitted_9[rover0,general,waypoint2] -> <_splitting_method_m8_send_soil_data_splitted_9;m8_send_soil_data_splitted_5[rover0,general,waypoint2,waypoint1];_splitting_method_m8_send_soil_data_splitted_5;1;0,-1> 55 62
29 send_soil_data[rover0,waypoint2] -> m8_send_soil_data 31
19 do_navigate2[rover0,waypoint1,waypoint2] -> m3_do_navigate2 20
15 do_navigate2[rover0,waypoint3,waypoint2] -> m4_do_navigate2 16 17 18 19 21
5 do_navigate1[rover0,waypoint2] -> m1_do_navigate1 6 7 15 22
2 empty_store[rover0store,rover0] -> m5_empty_store 23 24
1 empty_store[rover0store,rover0] -> m6_empty_store 105 106
0 __top[] -> <<<<<__top_method;get_image_data[objective1,high_res];m13_get_image_data;2;0,1,-1,-2,-3>;send_image_data[rover0,objective1,high_res];m14_send_image_data;4;0,1,2,3,-1>;do_calibrate[rover0,camera0];m15_do_calibrate;2;0,1,-1,3,4>;get_rock_data[waypoint3];m10_get_rock_data;1;0,-1,-2,-3,-4,2,3,4>;get_soil_data[waypoint2];m7_get_soil_data;0;-1,-2,-3,-4,1,2,3,4,5,6,7> 5 2 25 29 58 1 107 114 134 181 287
<==
Random seed: 42
Time limit: 1800 seconds
Reading input from domain-p10.psas.
- State has 388 bits divided into 388 mutex groups.
- Domain contains 2039 actions.
- Domain contains 6631 tasks.
- Domain contains 17548 methods.
- The initial state contains 54 set bits.
- The initial task is "__top[]".
- State-based goal contains 20 bits.
- Instance is totally-ordered: yes
- Instance has unique paths: yes
- Instance is parallel sequences: yes
Calculating preconditions and effects of compound tasks... 
- Inference time 0.759 seconds 
Calculate SCCs...
- Number of SCCs: 3623
- The problem is cyclic
- Number of cyclic SCCs: 377
- Number of cyclic SCCs of size 1: 0
Selected Planning Algorithm: progression searchParsing heuristics ...
Number of specified heuristics: 1
Generate 1

RC Factory: CMA 0
- a combination of cost estimate and admissible heuristic is used -> using admissible correction of heuristic value (this is bad when you do not want to find optimal plans).
Heuristic #0 = hhRC2(lmc;cost;correct count)
Search config:
 - type: cost optimal
 - weight: 1
 - suboptimal: false
Visited List configured
- mode: total order
- hashs to use: state task task-sequence
- memory information: topological ordering
- Visited list allows deletion of search nodes: true
Search Configuration
- Using JAIR 2020 progression algorithm
- Search is stopped after first solution is found.
- A* Search
- Distance G is "action costs"
  16s visitime    0.00s generated nodes      5004 nodes/sec     299 cur h   50 mod.depth   46 inserts       273 dups         7 size       266 hash fail      7 hash buckets    266
